.386
IDEAL
MODEL small
STACK 100h
p186
jumps
DATASEG
board dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h
dw 0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h,0ff00h

rowEnd db 13, 10, '$'  ; New line characters for DOS

selecteditemx db 10
selecteditemy db 10
num db 0
cxsaver dw 0
lpidx dw 0
tile dw 0000h
color dw 8h
hover_color dw 0fh 
counter db 0
read_x db 0
read_y db 0
mouse_state dw 0
ten dw 10

index_in_board dw 0
CODESEG
proc printboard
    pusha                  ; Save all general-purpose registers
    mov si, offset board ; SI points to the start of the matrix
    mov cx, 20
    

row_loop:
    mov bx, 20; Total elements in the matrix
    column_loop:
    mov ax, [si]          ; Get the matrix element (assuming it's small enough to be a single digit)
    add ax, '0'           ; Convert to ASCII
    mov dl, al            ; Prepare DL for output
    mov ah, 02h           ; DOS function: Print character
    int 21h               ; Call DOS interrupt
    
    add si, 2 
    dec bx
    cmp bx, 0; Move to the next element (16-bit, so 2 bytes)
    jg column_loop 
    mov dx, offset rowEnd
    mov ah, 9h
    int 21h; Loop until all elements are printed
    loop row_loop

    ; Print a newline at the very end (you might adjust this for row-wise printing)
             ; Loop through each row

    popa                   ; Restore all general-purpose registers
    ret
    endp printboard
    
    
    
    
proc draw_pixel
pusha

    xor bh, bh  ; bh = 0
    mov cx, [tile]
    mov dl, ch
    mov dh, 0
    mov ch, 0
    mov ax, [color]
    mov ah, 0ch
    int 10h
popa 
ret
endp draw_pixel

proc draw_tile
;hang on tight you sombiches
pusha
call readmouse
mov cx, [tile]
add cx, 10
sub cl, [read_x]
cmp cl, 10
jb row
jmp not_hover
row:
mov dx, [tile] 
add dh, 10
sub dh, [read_y]
cmp dh, 10
jb hover
jmp not_hover
hover:
mov [hover_color], 0fh
call readmouse
cmp [mouse_state], 1h
je left_click
cmp [mouse_state], 2h
je right_click
jmp begin
left_click:
call leftclick
jmp begin
right_click:
call rightclick
jmp begin
not_hover:
mov [hover_color], 8h

begin:
mov cx, 10d
line_1:
call draw_pixel
inc [tile]
loop line_1

sub [tile], 10d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_2:
call draw_pixel
inc [tile] 
loop line_2

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]

mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_3:
call draw_pixel
inc [tile]
loop line_3

mov [color], 7h
call draw_pixel

sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]

mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_4:
call draw_pixel
inc [tile]
loop line_4
mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h


call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_5:
call draw_pixel
inc [tile]
loop line_5

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_6:
call draw_pixel
inc [tile]
loop line_6

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_7:
call draw_pixel
inc [tile]
loop line_7

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_8:
call draw_pixel
inc [tile]
loop line_8

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_9:
call draw_pixel
inc [tile]
loop line_9

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

 
mov cx, 10d
line_10:
call draw_pixel
inc [tile]
loop line_10

sub [tile], 90ah
popa
ret
endp draw_tile

proc draw_board
pusha
mov ax,2h
int 33h
mov cx, 20
mov [counter], 0
line1:
call draw_tile
add [tile], 10d
loop line1
add [tile], 938h
inc [counter]
mov cx, 20
cmp [counter], 20
jl line1
mov [tile], 0

popa 
ret
endp draw_board

proc readmouse
pusha
mov ax,3h
int 33h
shr cx, 1
mov [read_x], cl
mov [read_y], dl
mov [mouse_state], bx
popa
ret
endp readmouse

proc leftclick
pusha
mov [hover_color], 4h
call getindex
mov si, [index_in_board]


mov [si], 0dh         ; Move the result back to CX

    ; Prepare AX and DX for the next divisio

popa
ret
endp leftclick

proc rightclick
pusha
mov [hover_color], 9h
call getindex
mov si, [index_in_board]


mov [si], 0eh         ; Move the result back to CX

    ; Prepare AX and DX for the next divisio

popa
ret
endp rightclick

proc getindex
pusha
mov si, [index_in_board]
mov bx, [tile]
mov ch, 0
mov cl, bh
mov bh, 0

mov ax, cx
mov cx, 4h
mul cx
mov cx, ax


mov ax, bx
mov bx, [ten]
xor dx, dx
div bx  
mov bx, ax 

mov si, offset board
add si, cx

add si, bx
add si, bx

mov [si], cx
mov [index_in_board], si
popa
ret
endp getindex


start:
    mov ax, @data
    mov ds, ax

    call printboard
    mov ax, 0h
    int 33h
    mov ax,1h
    int 33h
    mov ax, 13h
    int 10h
    ; call draw_pixel
    ;call draw_tile
   
    
gameloop:
    call draw_board
    call readmouse
    cmp [mouse_state], 3
    je out1
    jmp gameloop
    out1: 
    mov ax, 2h
    int 10h
    call printboard
exit:
    mov ax, 4c00h
    int 21h
END start