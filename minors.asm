.586
IDEAL
MODEL small
STACK 100h
jumps

DATASEG
board dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 
dw 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h 





 
winscreen db 'you won', 13,10,'$'
 



rowEnd db 13, 10, '$'  ; New line characters for DOS

selecteditemx db 10
selecteditemy db 10
num db 0
cxsaver dw 0
lpidx dw 0
tile dw 0000h
color dw 8h
hover_color dw 0fh 
counter db 0
read_x db 0
read_y db 0
mouse_state dw 0
ten dw 10
rnd dw 0

index_in_board dw 0
has_flag dw 0
x_flag db 0
y_flag db 0

mineplaced  dw 0
newmineplaced dw 0
minesplaced db 0d

x_dig db 0
y_dig db 0
num_color dw 0

index dw 0
corrects dw 0

CODESEG
proc printboard
    pusha                  ; Save all general-purpose registers
    mov si, offset board ; SI points to the start of the matrix
    mov cx, 20
    

row_loop:
    mov bx, 20; Total elements in the matrix
    column_loop:
    mov ax, [si]          ; Get the matrix element (assuming it's small enough to be a single digit)
    add ax, '0'           ; Convert to ASCII
    mov dl, ah            ; Prepare DL for output
    mov ah, 02h           ; DOS function: Print character
    int 21h               ; Call DOS interrupt
    
    add si, 2 
    dec bx
    cmp bx, 0; Move to the next element (16-bit, so 2 bytes)
    jg column_loop 
    mov dx, offset rowEnd
    mov ah, 9h
    int 21h; Loop until all elements are printed
    loop row_loop

    ; Print a newline at the very end (you might adjust this for row-wise printing)
             ; Loop through each row

    popa                   ; Restore all general-purpose registers
    ret
    endp printboard
    
    
proc random
; generates a random number and keeps it in rnd
    pusha

    mov ah, 0h
    int 1ah
    ;mov ax, 40h
    ;mov es, ax
    ; put random number in es
    ;mov ax, [es:6Ch]
    mov ax, dx
    xor dx, dx
    div [ten]
    ;mov dh, 0h
    mov [rnd], dx
    popa    
    ret
endp random

    
proc placemine
pusha
    mov ax,[newmineplaced]
    mov [mineplaced], ax
    mov si, offset board; only god knows what this does and we dont even know if he exists so ( ? ???)?
    call random
    mov bx ,[rnd]
    shl bx,1
    call readmouse
    mov bl, [read_x]
    mov ax , bx
    xor dx, dx
    ;mul [read_y]
    ;and al, 0fh 
    ;xor dx, dx
    ;mul [rnd]
    ;xor dx, dx
    
    shl ax, 2
    shr [rnd], 2
    add ax, [rnd]
    add si, ax
    mov [newmineplaced], si

;mov dl, [rnd]
;add si, dx
mov [si], 0dh
popa
ret
endp placemine

proc placemines
pusha

l1:
call draw_board
call placemine
mov ax, [newmineplaced]
cmp ax, [mineplaced]
jne newmine
jmp l1
newmine:
inc [minesplaced]
cmp [minesplaced], 20
jl l1

popa
ret
endp placemines
    
    
proc draw_pixel
pusha

    xor bh, bh  ; bh = 0
    mov cx, [tile]
    mov dl, ch
    mov dh, 0
    mov ch, 0
    mov ax, [color]
    mov ah, 0ch
    int 10h
popa 
ret
endp draw_pixel

proc draw_pixel_flag
pusha

    xor bh, bh  ; bh = 0
    xor cx, cx
    xor dx, dx
    mov dl, [y_flag]
    mov cl, [x_flag]
    mov ax, [color]
    mov ah, 0ch
    int 10h
popa 
ret
endp draw_pixel_flag

proc draw_pixel_digit;lord forgive me for im about to sin
pusha

    xor bh, bh
    xor cx, cx
    xor dx, dx
    mov dl, [y_dig]
    mov cl, [x_dig]
    mov ax, [num_color]
    mov ah, 0ch
    int 10h
popa 
ret
endp draw_pixel_digit

;; prepare your skull emojis

proc d1
add [x_dig], 3
add [y_dig], 3
call draw_pixel_digit
add [y_dig], 1
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
inc [x_dig]
inc [y_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
inc [y_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
ret
endp d1

proc d2
add [x_dig], 3
add [y_dig], 3
call draw_pixel_digit
inc [x_dig]
dec [y_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
inc [y_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
ret
endp d2

proc d3
add [x_dig], 3
add [y_dig], 2
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
add [x_dig], 2
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
ret
endp d3

proc d4
add [x_dig], 3
add [y_dig], 2
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
inc [y_dig] 
call draw_pixel_digit
sub [y_dig], 5h
inc [y_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
ret
endp d4

proc d5
add [x_dig], 5
add [y_dig], 2
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
inc [y_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
ret
endp d5

proc d6
add [x_dig], 5
add [y_dig], 2
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [y_dig]
call draw_pixel_digit
ret
endp d6

proc d7
add [x_dig], 3
add [y_dig], 2
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
inc [y_dig]
call draw_pixel_digit 
inc [y_dig]
call draw_pixel_digit
ret
endp d7

proc d8
add [x_dig], 5
add [y_dig], 3
call draw_pixel_digit
dec [y_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [x_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
inc [y_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [x_dig]
call draw_pixel_digit
dec [y_dig]
call draw_pixel_digit
ret
endp d8
;; why did i do this

proc draw_digits
pusha
cmp [num_color], 0
je finish_drawing
cmp [num_color], 1
je n1
cmp [num_color], 2
je n2
cmp [num_color], 3
je n3
cmp [num_color], 4
je n4
cmp [num_color], 5
je n5
cmp [num_color], 6
je n6
cmp [num_color], 7
je n7
cmp [num_color], 8
je n8

n1:
call d1
jmp finish_drawing
n2:
call d2
jmp finish_drawing
n3:
call d3
jmp finish_drawing
n4:
call d4
jmp finish_drawing
n5:
call d5
jmp finish_drawing
n6:
call d6
jmp finish_drawing
n7:
call d7
jmp finish_drawing
n8:
call d8
jmp finish_drawing
finish_drawing:

popa
ret
endp draw_digits



proc draw_tile
;hang on tight you sombiches
pusha
call readmouse
mov cx, [tile]
add cx, 10
sub cl, [read_x]
cmp cl, 10
jb row
jmp not_hover
row:
mov dx, [tile] 
add dh, 10
sub dh, [read_y]
cmp dh, 10
jb hover
jmp not_hover
hover:
mov [hover_color], 0fh
call readmouse
cmp [mouse_state], 1h
je left_click
cmp [mouse_state], 2h
je right_click
jmp begin
left_click:
call leftclick
jmp begin
right_click:
call rightclick
jmp begin
not_hover:

call getindex
mov [hover_color], 8h
mov si, [index_in_board]
mov ax, [si]
cmp ah, 0d0h
je revealed
jmp is_mine

revealed: 
mov [hover_color], 7h
jmp begin

is_mine:
call getindex
mov si, [index_in_board]
mov ax, [si]
cmp ah, 0f0h 
jne begin
mov [hover_color], 0;remove for game
;dont remove
inc [minesplaced]



begin:

mov cx, 10d
line_1:
call draw_pixel
inc [tile]
loop line_1

sub [tile], 10d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_2:
call draw_pixel
inc [tile] 
loop line_2

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]

mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_3:
call draw_pixel
inc [tile]
loop line_3

mov [color], 7h
call draw_pixel

sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]

mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_4:
call draw_pixel
inc [tile]
loop line_4
mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h


call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_5:
call draw_pixel
inc [tile]
loop line_5

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_6:
call draw_pixel
inc [tile]
loop line_6

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_7:
call draw_pixel
inc [tile]
loop line_7

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_8:
call draw_pixel
inc [tile]
loop line_8

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_9:
call draw_pixel
inc [tile]
loop line_9

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

 
mov cx, 10d
line_10:
call draw_pixel
inc [tile]
loop line_10

sub [tile], 90ah



call getindex
mov si, [index_in_board]
mov ax, [si]
cmp al, 0e0h
jne finish
mov bx, [tile]
mov [y_flag], 3
add [y_flag], bh
mov [x_flag], bl
call drawflag


finish:
;;;*takes off sunglasses*
;ma gawd in heaven,
;it works
;IT WORKS
;ITS ALIVE
call getindex
mov ax, [index_in_board]
mov [index], ax
call get_tile_number

mov si, [index_in_board]
mov ax, [si]
cmp ah, 0d0h
jne finish1
xor bx,bx
mov bl, al
mov [num_color], bx
mov bx, [tile]
mov [x_dig], bl
mov [y_dig], bh
call draw_digits
mov [x_dig], 0
mov [y_dig], 0
finish1:
mov [color], 7h
popa
ret
endp draw_tile 

proc draw_board
pusha
mov [minesplaced], 0 
mov ax,2h
int 33h
mov cx, 20
mov [counter], 0
line1:
call draw_tile

add [tile], 10d
loop line1
add [tile], 938h
inc [counter]
mov cx, 20
cmp [counter], 20
jl line1
mov [tile], 0
call checkwin
popa
ret
endp draw_board

proc readmouse
pusha
mov ax,3h
int 33h
shr cx, 1
mov [read_x], cl
mov [read_y], dl
mov [mouse_state], bx
popa
ret
endp readmouse;

proc reveal; i am a god how does this work
; why does it work
; im the greatest
; recursion? how does it work(i.e. magnets)
; HOW DOES THIS WORK THIS SHOULDNT WORK BUT IT DOES
; this is probably the best piece of assembly code ive ever written
pusha
mov si, [index]
mov bx, [si]
mov bh, 0d0h

mov [si], bx
call get_tile_number
cmp bl,1h
jae next3
mov ax, [si+2]
cmp ah,0ffh
jne next
mov[index], si
add [index], 2
call reveal
sub [index], 2

next:
mov ax, [si-2]
cmp ah,0ffh
jne next1
mov[index], si
sub [index], 2
call reveal
add [index], 2
next1:
mov ax, [si-40]
cmp ah,0ffh
jne next2
mov[index], si
sub [index], 40
call reveal
add [index], 40
next2:
mov ax, [si+40]
cmp ah,0ffh
jne next3
mov[index], si
add [index], 40
call reveal
sub [index], 40
next3:

;do same shit with all directions
popa
ret
endp reveal

proc leftclick
pusha
mov [hover_color], 4h
call getindex
mov si, [index_in_board]
mov ax, [si]
cmp ah, 0f0h
je exit 
mov [index], si
call reveal        ;
popa
ret
endp leftclick

proc rightclick
pusha
mov [hover_color], 9h
call getindex
mov si, [index_in_board]
mov bx, [si]
cmp bh, 0f0h
jne incorrect
inc [corrects]
incorrect:
mov al, 0e0h
cmp bl, al
je endrc
mov bl, al
mov [si], bx   

endrc:      
popa
ret
endp rightclick

proc getindex
pusha
mov si, [index_in_board]
mov bx, [tile]
mov ch, 0
mov cl, bh
mov bh, 0

mov ax, cx
mov cx, 4h
mul cx
mov cx, ax


mov ax, bx
mov bx, [ten]
xor dx, dx
div bx  
mov bx, ax 

mov si, offset board
add si, cx

add si, bx
add si, bx

mov [index_in_board], si
mov si, 0h
popa
ret
endp getindex

proc waitforchar
pusha
mov ah, 0h
int 16h
popa
ret
endp waitforchar

proc drawflag
pusha
 
    add [x_flag], 3
    mov [color], 4h
    call draw_pixel_flag
    inc [x_flag]
    call draw_pixel_flag
    dec [y_flag]
    call draw_pixel_flag
    mov [color], 14h
    inc [x_flag]
    call draw_pixel_flag
    inc [y_flag]
    call draw_pixel_flag
    inc [y_flag]
    call draw_pixel_flag
    inc [y_flag]
    call draw_pixel_flag
    inc [y_flag]
    call draw_pixel_flag
    inc [y_flag]
    call draw_pixel_flag
    inc [x_flag]
    call draw_pixel_flag
    inc [x_flag]
    call draw_pixel_flag
    sub [x_flag], 3
    call draw_pixel_flag
    dec [x_flag]
    call draw_pixel_flag
    mov [color], 7h
    mov [x_flag], 0
    mov [y_flag], 0
popa    
ret
endp drawflag

proc printNumber
pusha
;sets cursor on  the corner
mov dh, 19 ; row
mov dl, 35  ; column
mov bh, 0   ; page number
mov ah, 2
int 10h
mov al, [minesplaced]
xor dx, dx
div [ten]
mov cx, dx
mov dx, cx
mov ah, 2h
int 21h
add dx, '0'
xor dh, dh
mov ah, 2h
int 21h

popa
    ret 
endp printNumber

proc get_tile_number
pusha

mov si, [index]
mov ax, [si]
cmp ah, 0f0h
je no_num
mov ax, [si]
cmp al, 0e0h
je no_num



mov ax, [si+2]
call addoneif

mov ax, [si-2]
call addoneif

mov ax, [si+40]
call addoneif

mov ax, [si-40]
call addoneif

mov ax, [si+42]
call addoneif

mov ax, [si-38]
call addoneif

mov ax, [si-42]
call addoneif

mov ax, [si+38]
call addoneif


mov ax, [si]
mov al, cl
mov [si], ax 


no_num:
popa
ret 
endp get_tile_number

proc addoneif
cmp ah, 0f0h
jne dont_add

inc cx
dont_add:

ret
endp addoneif

proc checkwin
pusha
    mov ax, [corrects]
    ;dec [corrects]
    cmp al, [minesplaced]
    jl nowin
    mov ah, 00h
    mov al, 03h
    int 10h
    mov dx, offset winscreen
    mov ah, 9h
    int 21h
    jmp exit
nowin:
    
popa
ret
endp checkwin


start:
    mov ax, @data
    mov ds, ax

    call printboard
    mov ax, 0h
    int 33h
    mov ax,1h
    int 33h
    mov ax, 13h
    int 10h
    ; call draw_pixel
    ;call draw_tile
   
    call draw_board
    ;call printNumber
    ;call placemines
gameloop:
    ;call placemine
   
    call draw_board
    call readmouse
    cmp [mouse_state], 3
    je out1
    
    jmp gameloop
    
    out1: 
    mov ax, 2h
    int 10h
    call printboard
    call waitforchar
    ;call placemine
exit:
    mov ax, 4c00h
    int 21h
    END start