.586
IDEAL
MODEL small
STACK 100h
jumps

DATASEG
board dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 
dw 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0ff00h, 0f000h, 0ff00h, 0ff00h, 0ff00h, 0ff00h,
 

 



rowEnd db 13, 10, '$'  ; New line characters for DOS

selecteditemx db 10
selecteditemy db 10
num db 0
cxsaver dw 0
lpidx dw 0
tile dw 0000h
color dw 8h
hover_color dw 0fh 
counter db 0
read_x db 0
read_y db 0
mouse_state dw 0
ten dw 10
rnd dw 0

index_in_board dw 0
has_flag dw 0
x_flag db 0
y_flag db 0

mineplaced  dw 0
newmineplaced dw 0
minesplaced dw 0

CODESEG
proc printboard
    pusha                  ; Save all general-purpose registers
    mov si, offset board ; SI points to the start of the matrix
    mov cx, 20
    

row_loop:
    mov bx, 20; Total elements in the matrix
    column_loop:
    mov ax, [si]          ; Get the matrix element (assuming it's small enough to be a single digit)
    add ax, '0'           ; Convert to ASCII
    mov dl, ah            ; Prepare DL for output
    mov ah, 02h           ; DOS function: Print character
    int 21h               ; Call DOS interrupt
    
    add si, 2 
    dec bx
    cmp bx, 0; Move to the next element (16-bit, so 2 bytes)
    jg column_loop 
    mov dx, offset rowEnd
    mov ah, 9h
    int 21h; Loop until all elements are printed
    loop row_loop

    ; Print a newline at the very end (you might adjust this for row-wise printing)
             ; Loop through each row

    popa                   ; Restore all general-purpose registers
    ret
    endp printboard
    
    
proc random
; generates a random number and keeps it in rnd
    pusha
; put segment number in register es
    mov ah, 0h
    int 1ah
    ;mov ax, 40h
    ;mov es, ax
; move random number to ax
    ;mov ax, [es:6Ch]
    mov ax, dx
    xor dx, dx
    div [ten]
    ;mov dh, 0h
    mov [rnd], dx
    popa    
    ret
endp random

    
proc placemine
pusha
    mov ax,[newmineplaced]
    mov [mineplaced], ax
    mov si, offset board; only god knows what this does and we dont even know if he exists so ( ? ???)?
    call random
    mov bx ,[rnd]
    shl bx,1
    call readmouse
    mov bl, [read_x]
    mov ax , bx
    xor dx, dx
    ;mul [read_y]
    ;and al, 0fh 
    ;xor dx, dx
    ;mul [rnd]
    ;xor dx, dx
    
    shl ax, 2
    shr [rnd], 2
    add ax, [rnd]
    add si, ax
    mov [newmineplaced], si

;mov dl, [rnd]
;add si, dx
mov [si], 0dh
popa
ret
endp placemine

proc placemines
pusha

l1:
call draw_board
call placemine
mov ax, [newmineplaced]
cmp ax, [mineplaced]
jne newmine
jmp l1
newmine:
inc [minesplaced]
cmp [minesplaced], 20
jl l1

popa
ret
endp placemines
    
    
proc draw_pixel
pusha

    xor bh, bh  ; bh = 0
    mov cx, [tile]
    mov dl, ch
    mov dh, 0
    mov ch, 0
    mov ax, [color]
    mov ah, 0ch
    int 10h
popa 
ret
endp draw_pixel

proc draw_pixel_flag
pusha

    xor bh, bh  ; bh = 0
    xor cx, cx
    xor dx, dx
    mov dl, [y_flag]
    mov cl, [x_flag]
    mov ax, [color]
    mov ah, 0ch
    int 10h
popa 
ret
endp draw_pixel_flag


proc draw_tile
;hang on tight you sombiches
pusha
call readmouse
mov cx, [tile]
add cx, 10
sub cl, [read_x]
cmp cl, 10
jb row
jmp not_hover
row:
mov dx, [tile] 
add dh, 10
sub dh, [read_y]
cmp dh, 10
jb hover
jmp not_hover
hover:
mov [hover_color], 0fh
call readmouse
cmp [mouse_state], 1h
je left_click
cmp [mouse_state], 2h
je right_click
jmp begin
left_click:
call leftclick
jmp begin
right_click:
call rightclick
jmp begin
not_hover:

call getindex
mov [hover_color], 8h
mov si, [index_in_board]
mov ax, [si]
cmp ax, 0d000h
je revealed
jmp is_mine
revealed:
mov [hover_color], 7h
jmp begin

is_mine:
call getindex
mov si, [index_in_board]
mov ax, [si]
cmp ah, 0f0h 
jne begin
mov [hover_color], 0;remove for game
;dont remove
inc [minesplaced]

begin:

mov cx, 10d
line_1:
call draw_pixel
inc [tile]
loop line_1

sub [tile], 10d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_2:
call draw_pixel
inc [tile] 
loop line_2

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]

mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_3:
call draw_pixel
inc [tile]
loop line_3

mov [color], 7h
call draw_pixel

sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]

mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_4:
call draw_pixel
inc [tile]
loop line_4
mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h


call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_5:
call draw_pixel
inc [tile]
loop line_5

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_6:
call draw_pixel
inc [tile]
loop line_6

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_7:
call draw_pixel
inc [tile]
loop line_7

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_8:
call draw_pixel
inc [tile]
loop line_8

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

call draw_pixel
inc [tile]
mov cx, 8d
mov ax, [hover_color]
mov [color], ax

line_9:
call draw_pixel
inc [tile]
loop line_9

mov [color], 7h
call draw_pixel


sub [tile], 9d
add [tile],100h

 
mov cx, 10d
line_10:
call draw_pixel
inc [tile]
loop line_10

sub [tile], 90ah
call getindex
mov si, [index_in_board]
mov ax, [si]
cmp al, 0e0h
jne finish
mov bx, [tile]
mov [y_flag], 3
add [y_flag], bh
mov [x_flag], bl
call drawflag
finish:

popa
ret
endp draw_tile 

proc draw_board
pusha
mov ax,2h
int 33h
mov cx, 20
mov [counter], 0
line1:
call draw_tile
add [tile], 10d
loop line1
add [tile], 938h
inc [counter]
mov cx, 20
cmp [counter], 20
jl line1
mov [tile], 0

popa 
ret
endp draw_board

proc readmouse
pusha
mov ax,3h
int 33h
shr cx, 1
mov [read_x], cl
mov [read_y], dl
mov [mouse_state], bx
popa
ret
endp readmouse

proc leftclick
pusha
mov [hover_color], 4h
call getindex
mov si, [index_in_board]
mov ax, 0d000h
mov [si], ax         ;
popa
ret
endp leftclick

proc rightclick
pusha
mov [hover_color], 9h
call getindex
mov si, [index_in_board]
mov bx, [si]
mov al, 0e0h
mov bl, al
mov [si], bx         
popa
ret
endp rightclick

proc getindex
pusha
mov si, [index_in_board]
mov bx, [tile]
mov ch, 0
mov cl, bh
mov bh, 0

mov ax, cx
mov cx, 4h
mul cx
mov cx, ax


mov ax, bx
mov bx, [ten]
xor dx, dx
div bx  
mov bx, ax 

mov si, offset board
add si, cx

add si, bx
add si, bx

mov [index_in_board], si
mov si, 0h
popa
ret
endp getindex

proc waitforchar
pusha
mov ah, 0h
int 16h
popa
ret
endp waitforchar

proc drawflag
pusha
 
    add [x_flag], 3
    mov [color], 4h
    call draw_pixel_flag
    inc [x_flag]
    call draw_pixel_flag
    dec [y_flag]
    call draw_pixel_flag
    mov [color], 14h
    inc [x_flag]
    call draw_pixel_flag
    inc [y_flag]
    call draw_pixel_flag
    inc [y_flag]
    call draw_pixel_flag
    inc [y_flag]
    call draw_pixel_flag
    inc [y_flag]
    call draw_pixel_flag
    inc [y_flag]
    call draw_pixel_flag
    inc [x_flag]
    call draw_pixel_flag
    inc [x_flag]
    call draw_pixel_flag
    sub [x_flag], 3
    call draw_pixel_flag
    dec [x_flag]
    call draw_pixel_flag
    mov [color], 7h
    mov [x_flag], 0
    mov [y_flag], 0
popa    
ret
endp drawflag


start:
    mov ax, @data
    mov ds, ax

    call printboard
    mov ax, 0h
    int 33h
    mov ax,1h
    int 33h
    mov ax, 13h
    int 10h
    ; call draw_pixel
    ;call draw_tile
   
    
    ;call placemines
gameloop:
    ;call placemine
    call draw_board
    call readmouse
    cmp [mouse_state], 3
    je out1
    jmp gameloop
    out1: 
    mov ax, 2h
    int 10h
    call printboard
    call waitforchar
    ;call placemine
exit:
    mov ax, 4c00h
    int 21h
    END start